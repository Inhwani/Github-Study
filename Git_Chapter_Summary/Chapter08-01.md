# 8.5 충돌

충돌은 3-WAY 병합이 실패한 경우.

# 8.5.1 충돌이 생기는 상황

대부분의 충돌 원인은 같은 위치의 코드를 동시에 수정했기 때문.

# 8.5.2

충돌이 발생하면 깃은 "merge conflicts" 메시지를 출력함

병합 충돌이 발생하면 자동으로 커밋이 생성되지 않는다는 것.

# 8.5.3 수동으로 충돌 해결

병합 충돌이 발생하면 결국 수동으로 해결해야 함.

충돌한 내용을 수정할 때는 깃에서 표시한 충돌 기호도 함께 삭제해야 함.

충돌을 해결한 후 병합 커밋을 직접 만들어야 함.

# 8.6 브랜치 병합 여부 확인

```
$ git branch --merged
```

병합한 브랜치와 병합하지 않은 브랜치를 구분하는 옵션

```
$ git branch --no--merged
```

병합하지 않은 브랜치를 확인하는 명령어.

# 8.7 리베이스

브랜치를 합치는 방법은 병합과 리베이스임.

# 8.7.1 베이스

모든 브랜치는 뿌리가 있다.

브랜치는 특정 커밋을 가리키는 포인터임. 가리키는 특정 커밋은

브랜치가 파생된 기준이 됨.

새로운 브랜치가 파생되는 커밋을 베이스라고 함. 병합에서는 이를 공통 조상 커밋이라고 함.

# 8.7.2 베이스 변경

리베이스는 베이스 앞에 re가 붙은 단어임.

리베이스는 커밋의 트리 구조를 재벼열함 . 커밋을 재별하는 변경 결과가 병합과 유사함.

실무에서는 병합보단 rebase방식을 많이 사용함.

리베이스는 코드의 베이스 분기점을 변경하여 마치 하나의 기찻길처럼 만듬.

여러 갈래로 갈라지지 않아 커밋의 진행 사항을 좀 더 쉽게 파악 가능.

# 8.7.3 리베이스 vs 병합

병합은 파생된 두 브랜치를 하나로 합치는 과정

병합하는 두 브랜치는 순차적으로 커밋을 비교하면서 마지막 최종 커밋을 생성함.

반면 리베이스는 두 브랜치를 서로 비교하지 않고 순차적으로 커밋 병합을 시도함.

리베이스를 하면 먼저 공통 조상 커밋을 찾습니다.

파생된 브랜치의 diff를 임시 공간에 잠시 보관함.

새로운 베이스 기준점을 기반으로 한 브랜치에서 커밋을 연장하여 수정 재배치함.

결과적으로 브랜치의 커밋은 최종 코드로 모든 코드 내용이 반영되어 있음.

# 8.7.4 리베이스 명령어

```
$ git rebase 브랜치
```

리베이스 작업 명령어.

# 8.7.5 리베이스 병합

리베이스는 병합 기준 브랜치가 merge 명령어와 반대임.

merge 명령어를 사용한 병합은 현재의 기준 브랜치에서 다른 브랜치를 읽어 와서 결합함.

하지만 리베이스는 병합되는 브랜치 방향이 반대됨.

원본 브랜치를 파생 브랜치에 붙이는 방식.

# 8.7.8 리베이스 충돌과 해결

리베이스는 기준점을 변경함. 리베이스 역시 병합 과정에서 충돌이 발생할 수 있음.

리베이스는 커밋을 하나씩 따라가면서 위치를 재조정함. 충돌을 수정한 후에는

rebase 명령어와 --continue 옵션을 사용함

```
$ git rebase --continue
```
rebase  충돌된 부분들을 한 단계씩 해결해 나가면서 병합 가능함.

# 8.7.9 rebase 명령어로 커밋 수정

마지막 커밋은 --amend 옵션으로 수정할 수 있음 rebase 명령어로도 최종 커밋을 수정할 수 있음.
